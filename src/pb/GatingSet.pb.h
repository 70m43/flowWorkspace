// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GatingSet.proto

#ifndef PROTOBUF_GatingSet_2eproto__INCLUDED
#define PROTOBUF_GatingSet_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_GatingSet_2eproto();
void protobuf_AssignDesc_GatingSet_2eproto();
void protobuf_ShutdownFile_GatingSet_2eproto();

class gate;
class POPSTATS;
class POPINDICES;
class nodeProperties;
class treeNodes;
class populationTree;
class GatingHierarchy;
class ghPair;
class GatingSet;

enum ind_type {
  BOOL = 0,
  INT = 1,
  ROOT = 2
};
bool ind_type_IsValid(int value);
const ind_type ind_type_MIN = BOOL;
const ind_type ind_type_MAX = ROOT;
const int ind_type_ARRAYSIZE = ind_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ind_type_descriptor();
inline const ::std::string& ind_type_Name(ind_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ind_type_descriptor(), value);
}
inline bool ind_type_Parse(
    const ::std::string& name, ind_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ind_type>(
    ind_type_descriptor(), name, value);
}
// ===================================================================

class gate : public ::google::protobuf::Message {
 public:
  gate();
  virtual ~gate();

  gate(const gate& from);

  inline gate& operator=(const gate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gate& default_instance();

  void Swap(gate* other);

  // implements Message ----------------------------------------------

  gate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gate& from);
  void MergeFrom(const gate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool neg = 1;
  inline bool has_neg() const;
  inline void clear_neg();
  static const int kNegFieldNumber = 1;
  inline bool neg() const;
  inline void set_neg(bool value);

  // required bool isTransformed = 2;
  inline bool has_istransformed() const;
  inline void clear_istransformed();
  static const int kIsTransformedFieldNumber = 2;
  inline bool istransformed() const;
  inline void set_istransformed(bool value);

  // required bool isGained = 3;
  inline bool has_isgained() const;
  inline void clear_isgained();
  static const int kIsGainedFieldNumber = 3;
  inline bool isgained() const;
  inline void set_isgained(bool value);

  // @@protoc_insertion_point(class_scope:pb.gate)
 private:
  inline void set_has_neg();
  inline void clear_has_neg();
  inline void set_has_istransformed();
  inline void clear_has_istransformed();
  inline void set_has_isgained();
  inline void clear_has_isgained();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool neg_;
  bool istransformed_;
  bool isgained_;
  friend void  protobuf_AddDesc_GatingSet_2eproto();
  friend void protobuf_AssignDesc_GatingSet_2eproto();
  friend void protobuf_ShutdownFile_GatingSet_2eproto();

  void InitAsDefaultInstance();
  static gate* default_instance_;
};
// -------------------------------------------------------------------

class POPSTATS : public ::google::protobuf::Message {
 public:
  POPSTATS();
  virtual ~POPSTATS();

  POPSTATS(const POPSTATS& from);

  inline POPSTATS& operator=(const POPSTATS& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const POPSTATS& default_instance();

  void Swap(POPSTATS* other);

  // implements Message ----------------------------------------------

  POPSTATS* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const POPSTATS& from);
  void MergeFrom(const POPSTATS& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string statType = 1;
  inline bool has_stattype() const;
  inline void clear_stattype();
  static const int kStatTypeFieldNumber = 1;
  inline const ::std::string& stattype() const;
  inline void set_stattype(const ::std::string& value);
  inline void set_stattype(const char* value);
  inline void set_stattype(const char* value, size_t size);
  inline ::std::string* mutable_stattype();
  inline ::std::string* release_stattype();
  inline void set_allocated_stattype(::std::string* stattype);

  // required float statVal = 2;
  inline bool has_statval() const;
  inline void clear_statval();
  static const int kStatValFieldNumber = 2;
  inline float statval() const;
  inline void set_statval(float value);

  // @@protoc_insertion_point(class_scope:pb.POPSTATS)
 private:
  inline void set_has_stattype();
  inline void clear_has_stattype();
  inline void set_has_statval();
  inline void clear_has_statval();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* stattype_;
  float statval_;
  friend void  protobuf_AddDesc_GatingSet_2eproto();
  friend void protobuf_AssignDesc_GatingSet_2eproto();
  friend void protobuf_ShutdownFile_GatingSet_2eproto();

  void InitAsDefaultInstance();
  static POPSTATS* default_instance_;
};
// -------------------------------------------------------------------

class POPINDICES : public ::google::protobuf::Message {
 public:
  POPINDICES();
  virtual ~POPINDICES();

  POPINDICES(const POPINDICES& from);

  inline POPINDICES& operator=(const POPINDICES& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const POPINDICES& default_instance();

  void Swap(POPINDICES* other);

  // implements Message ----------------------------------------------

  POPINDICES* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const POPINDICES& from);
  void MergeFrom(const POPINDICES& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 nEvents = 1;
  inline bool has_nevents() const;
  inline void clear_nevents();
  static const int kNEventsFieldNumber = 1;
  inline ::google::protobuf::uint32 nevents() const;
  inline void set_nevents(::google::protobuf::uint32 value);

  // required .pb.ind_type indtype = 2;
  inline bool has_indtype() const;
  inline void clear_indtype();
  static const int kIndtypeFieldNumber = 2;
  inline ::pb::ind_type indtype() const;
  inline void set_indtype(::pb::ind_type value);

  // repeated fixed32 iInd = 3;
  inline int iind_size() const;
  inline void clear_iind();
  static const int kIIndFieldNumber = 3;
  inline ::google::protobuf::uint32 iind(int index) const;
  inline void set_iind(int index, ::google::protobuf::uint32 value);
  inline void add_iind(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      iind() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_iind();

  // repeated bool bInd = 4;
  inline int bind_size() const;
  inline void clear_bind();
  static const int kBIndFieldNumber = 4;
  inline bool bind(int index) const;
  inline void set_bind(int index, bool value);
  inline void add_bind(bool value);
  inline const ::google::protobuf::RepeatedField< bool >&
      bind() const;
  inline ::google::protobuf::RepeatedField< bool >*
      mutable_bind();

  // @@protoc_insertion_point(class_scope:pb.POPINDICES)
 private:
  inline void set_has_nevents();
  inline void clear_has_nevents();
  inline void set_has_indtype();
  inline void clear_has_indtype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 nevents_;
  int indtype_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > iind_;
  ::google::protobuf::RepeatedField< bool > bind_;
  friend void  protobuf_AddDesc_GatingSet_2eproto();
  friend void protobuf_AssignDesc_GatingSet_2eproto();
  friend void protobuf_ShutdownFile_GatingSet_2eproto();

  void InitAsDefaultInstance();
  static POPINDICES* default_instance_;
};
// -------------------------------------------------------------------

class nodeProperties : public ::google::protobuf::Message {
 public:
  nodeProperties();
  virtual ~nodeProperties();

  nodeProperties(const nodeProperties& from);

  inline nodeProperties& operator=(const nodeProperties& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const nodeProperties& default_instance();

  void Swap(nodeProperties* other);

  // implements Message ----------------------------------------------

  nodeProperties* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const nodeProperties& from);
  void MergeFrom(const nodeProperties& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string thisName = 1;
  inline bool has_thisname() const;
  inline void clear_thisname();
  static const int kThisNameFieldNumber = 1;
  inline const ::std::string& thisname() const;
  inline void set_thisname(const ::std::string& value);
  inline void set_thisname(const char* value);
  inline void set_thisname(const char* value, size_t size);
  inline ::std::string* mutable_thisname();
  inline ::std::string* release_thisname();
  inline void set_allocated_thisname(::std::string* thisname);

  // repeated .pb.POPSTATS fjStats = 2;
  inline int fjstats_size() const;
  inline void clear_fjstats();
  static const int kFjStatsFieldNumber = 2;
  inline const ::pb::POPSTATS& fjstats(int index) const;
  inline ::pb::POPSTATS* mutable_fjstats(int index);
  inline ::pb::POPSTATS* add_fjstats();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::POPSTATS >&
      fjstats() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::POPSTATS >*
      mutable_fjstats();

  // repeated .pb.POPSTATS fcStats = 3;
  inline int fcstats_size() const;
  inline void clear_fcstats();
  static const int kFcStatsFieldNumber = 3;
  inline const ::pb::POPSTATS& fcstats(int index) const;
  inline ::pb::POPSTATS* mutable_fcstats(int index);
  inline ::pb::POPSTATS* add_fcstats();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::POPSTATS >&
      fcstats() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::POPSTATS >*
      mutable_fcstats();

  // required bool hidden = 4;
  inline bool has_hidden() const;
  inline void clear_hidden();
  static const int kHiddenFieldNumber = 4;
  inline bool hidden() const;
  inline void set_hidden(bool value);

  // required .pb.POPINDICES indices = 5;
  inline bool has_indices() const;
  inline void clear_indices();
  static const int kIndicesFieldNumber = 5;
  inline const ::pb::POPINDICES& indices() const;
  inline ::pb::POPINDICES* mutable_indices();
  inline ::pb::POPINDICES* release_indices();
  inline void set_allocated_indices(::pb::POPINDICES* indices);

  // required .pb.gate thisGate = 6;
  inline bool has_thisgate() const;
  inline void clear_thisgate();
  static const int kThisGateFieldNumber = 6;
  inline const ::pb::gate& thisgate() const;
  inline ::pb::gate* mutable_thisgate();
  inline ::pb::gate* release_thisgate();
  inline void set_allocated_thisgate(::pb::gate* thisgate);

  // @@protoc_insertion_point(class_scope:pb.nodeProperties)
 private:
  inline void set_has_thisname();
  inline void clear_has_thisname();
  inline void set_has_hidden();
  inline void clear_has_hidden();
  inline void set_has_indices();
  inline void clear_has_indices();
  inline void set_has_thisgate();
  inline void clear_has_thisgate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* thisname_;
  ::google::protobuf::RepeatedPtrField< ::pb::POPSTATS > fjstats_;
  ::google::protobuf::RepeatedPtrField< ::pb::POPSTATS > fcstats_;
  ::pb::POPINDICES* indices_;
  ::pb::gate* thisgate_;
  bool hidden_;
  friend void  protobuf_AddDesc_GatingSet_2eproto();
  friend void protobuf_AssignDesc_GatingSet_2eproto();
  friend void protobuf_ShutdownFile_GatingSet_2eproto();

  void InitAsDefaultInstance();
  static nodeProperties* default_instance_;
};
// -------------------------------------------------------------------

class treeNodes : public ::google::protobuf::Message {
 public:
  treeNodes();
  virtual ~treeNodes();

  treeNodes(const treeNodes& from);

  inline treeNodes& operator=(const treeNodes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const treeNodes& default_instance();

  void Swap(treeNodes* other);

  // implements Message ----------------------------------------------

  treeNodes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const treeNodes& from);
  void MergeFrom(const treeNodes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.nodeProperties node = 1;
  inline bool has_node() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 1;
  inline const ::pb::nodeProperties& node() const;
  inline ::pb::nodeProperties* mutable_node();
  inline ::pb::nodeProperties* release_node();
  inline void set_allocated_node(::pb::nodeProperties* node);

  // required fixed32 parent = 2;
  inline bool has_parent() const;
  inline void clear_parent();
  static const int kParentFieldNumber = 2;
  inline ::google::protobuf::uint32 parent() const;
  inline void set_parent(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.treeNodes)
 private:
  inline void set_has_node();
  inline void clear_has_node();
  inline void set_has_parent();
  inline void clear_has_parent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::pb::nodeProperties* node_;
  ::google::protobuf::uint32 parent_;
  friend void  protobuf_AddDesc_GatingSet_2eproto();
  friend void protobuf_AssignDesc_GatingSet_2eproto();
  friend void protobuf_ShutdownFile_GatingSet_2eproto();

  void InitAsDefaultInstance();
  static treeNodes* default_instance_;
};
// -------------------------------------------------------------------

class populationTree : public ::google::protobuf::Message {
 public:
  populationTree();
  virtual ~populationTree();

  populationTree(const populationTree& from);

  inline populationTree& operator=(const populationTree& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const populationTree& default_instance();

  void Swap(populationTree* other);

  // implements Message ----------------------------------------------

  populationTree* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const populationTree& from);
  void MergeFrom(const populationTree& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pb.treeNodes node = 1;
  inline int node_size() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 1;
  inline const ::pb::treeNodes& node(int index) const;
  inline ::pb::treeNodes* mutable_node(int index);
  inline ::pb::treeNodes* add_node();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::treeNodes >&
      node() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::treeNodes >*
      mutable_node();

  // @@protoc_insertion_point(class_scope:pb.populationTree)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::pb::treeNodes > node_;
  friend void  protobuf_AddDesc_GatingSet_2eproto();
  friend void protobuf_AssignDesc_GatingSet_2eproto();
  friend void protobuf_ShutdownFile_GatingSet_2eproto();

  void InitAsDefaultInstance();
  static populationTree* default_instance_;
};
// -------------------------------------------------------------------

class GatingHierarchy : public ::google::protobuf::Message {
 public:
  GatingHierarchy();
  virtual ~GatingHierarchy();

  GatingHierarchy(const GatingHierarchy& from);

  inline GatingHierarchy& operator=(const GatingHierarchy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GatingHierarchy& default_instance();

  void Swap(GatingHierarchy* other);

  // implements Message ----------------------------------------------

  GatingHierarchy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GatingHierarchy& from);
  void MergeFrom(const GatingHierarchy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.populationTree tree = 2;
  inline bool has_tree() const;
  inline void clear_tree();
  static const int kTreeFieldNumber = 2;
  inline const ::pb::populationTree& tree() const;
  inline ::pb::populationTree* mutable_tree();
  inline ::pb::populationTree* release_tree();
  inline void set_allocated_tree(::pb::populationTree* tree);

  // @@protoc_insertion_point(class_scope:pb.GatingHierarchy)
 private:
  inline void set_has_tree();
  inline void clear_has_tree();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::pb::populationTree* tree_;
  friend void  protobuf_AddDesc_GatingSet_2eproto();
  friend void protobuf_AssignDesc_GatingSet_2eproto();
  friend void protobuf_ShutdownFile_GatingSet_2eproto();

  void InitAsDefaultInstance();
  static GatingHierarchy* default_instance_;
};
// -------------------------------------------------------------------

class ghPair : public ::google::protobuf::Message {
 public:
  ghPair();
  virtual ~ghPair();

  ghPair(const ghPair& from);

  inline ghPair& operator=(const ghPair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ghPair& default_instance();

  void Swap(ghPair* other);

  // implements Message ----------------------------------------------

  ghPair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ghPair& from);
  void MergeFrom(const ghPair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.GatingHierarchy gh = 1;
  inline bool has_gh() const;
  inline void clear_gh();
  static const int kGhFieldNumber = 1;
  inline const ::pb::GatingHierarchy& gh() const;
  inline ::pb::GatingHierarchy* mutable_gh();
  inline ::pb::GatingHierarchy* release_gh();
  inline void set_allocated_gh(::pb::GatingHierarchy* gh);

  // required string sampleName = 2;
  inline bool has_samplename() const;
  inline void clear_samplename();
  static const int kSampleNameFieldNumber = 2;
  inline const ::std::string& samplename() const;
  inline void set_samplename(const ::std::string& value);
  inline void set_samplename(const char* value);
  inline void set_samplename(const char* value, size_t size);
  inline ::std::string* mutable_samplename();
  inline ::std::string* release_samplename();
  inline void set_allocated_samplename(::std::string* samplename);

  // @@protoc_insertion_point(class_scope:pb.ghPair)
 private:
  inline void set_has_gh();
  inline void clear_has_gh();
  inline void set_has_samplename();
  inline void clear_has_samplename();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::pb::GatingHierarchy* gh_;
  ::std::string* samplename_;
  friend void  protobuf_AddDesc_GatingSet_2eproto();
  friend void protobuf_AssignDesc_GatingSet_2eproto();
  friend void protobuf_ShutdownFile_GatingSet_2eproto();

  void InitAsDefaultInstance();
  static ghPair* default_instance_;
};
// -------------------------------------------------------------------

class GatingSet : public ::google::protobuf::Message {
 public:
  GatingSet();
  virtual ~GatingSet();

  GatingSet(const GatingSet& from);

  inline GatingSet& operator=(const GatingSet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GatingSet& default_instance();

  void Swap(GatingSet* other);

  // implements Message ----------------------------------------------

  GatingSet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GatingSet& from);
  void MergeFrom(const GatingSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pb.ghPair ghs = 1;
  inline int ghs_size() const;
  inline void clear_ghs();
  static const int kGhsFieldNumber = 1;
  inline const ::pb::ghPair& ghs(int index) const;
  inline ::pb::ghPair* mutable_ghs(int index);
  inline ::pb::ghPair* add_ghs();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::ghPair >&
      ghs() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::ghPair >*
      mutable_ghs();

  // @@protoc_insertion_point(class_scope:pb.GatingSet)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::pb::ghPair > ghs_;
  friend void  protobuf_AddDesc_GatingSet_2eproto();
  friend void protobuf_AssignDesc_GatingSet_2eproto();
  friend void protobuf_ShutdownFile_GatingSet_2eproto();

  void InitAsDefaultInstance();
  static GatingSet* default_instance_;
};
// ===================================================================


// ===================================================================

// gate

// required bool neg = 1;
inline bool gate::has_neg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gate::set_has_neg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gate::clear_has_neg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gate::clear_neg() {
  neg_ = false;
  clear_has_neg();
}
inline bool gate::neg() const {
  // @@protoc_insertion_point(field_get:pb.gate.neg)
  return neg_;
}
inline void gate::set_neg(bool value) {
  set_has_neg();
  neg_ = value;
  // @@protoc_insertion_point(field_set:pb.gate.neg)
}

// required bool isTransformed = 2;
inline bool gate::has_istransformed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gate::set_has_istransformed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gate::clear_has_istransformed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gate::clear_istransformed() {
  istransformed_ = false;
  clear_has_istransformed();
}
inline bool gate::istransformed() const {
  // @@protoc_insertion_point(field_get:pb.gate.isTransformed)
  return istransformed_;
}
inline void gate::set_istransformed(bool value) {
  set_has_istransformed();
  istransformed_ = value;
  // @@protoc_insertion_point(field_set:pb.gate.isTransformed)
}

// required bool isGained = 3;
inline bool gate::has_isgained() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void gate::set_has_isgained() {
  _has_bits_[0] |= 0x00000004u;
}
inline void gate::clear_has_isgained() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void gate::clear_isgained() {
  isgained_ = false;
  clear_has_isgained();
}
inline bool gate::isgained() const {
  // @@protoc_insertion_point(field_get:pb.gate.isGained)
  return isgained_;
}
inline void gate::set_isgained(bool value) {
  set_has_isgained();
  isgained_ = value;
  // @@protoc_insertion_point(field_set:pb.gate.isGained)
}

// -------------------------------------------------------------------

// POPSTATS

// required string statType = 1;
inline bool POPSTATS::has_stattype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void POPSTATS::set_has_stattype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void POPSTATS::clear_has_stattype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void POPSTATS::clear_stattype() {
  if (stattype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stattype_->clear();
  }
  clear_has_stattype();
}
inline const ::std::string& POPSTATS::stattype() const {
  // @@protoc_insertion_point(field_get:pb.POPSTATS.statType)
  return *stattype_;
}
inline void POPSTATS::set_stattype(const ::std::string& value) {
  set_has_stattype();
  if (stattype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stattype_ = new ::std::string;
  }
  stattype_->assign(value);
  // @@protoc_insertion_point(field_set:pb.POPSTATS.statType)
}
inline void POPSTATS::set_stattype(const char* value) {
  set_has_stattype();
  if (stattype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stattype_ = new ::std::string;
  }
  stattype_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.POPSTATS.statType)
}
inline void POPSTATS::set_stattype(const char* value, size_t size) {
  set_has_stattype();
  if (stattype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stattype_ = new ::std::string;
  }
  stattype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.POPSTATS.statType)
}
inline ::std::string* POPSTATS::mutable_stattype() {
  set_has_stattype();
  if (stattype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stattype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.POPSTATS.statType)
  return stattype_;
}
inline ::std::string* POPSTATS::release_stattype() {
  clear_has_stattype();
  if (stattype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = stattype_;
    stattype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void POPSTATS::set_allocated_stattype(::std::string* stattype) {
  if (stattype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete stattype_;
  }
  if (stattype) {
    set_has_stattype();
    stattype_ = stattype;
  } else {
    clear_has_stattype();
    stattype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.POPSTATS.statType)
}

// required float statVal = 2;
inline bool POPSTATS::has_statval() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void POPSTATS::set_has_statval() {
  _has_bits_[0] |= 0x00000002u;
}
inline void POPSTATS::clear_has_statval() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void POPSTATS::clear_statval() {
  statval_ = 0;
  clear_has_statval();
}
inline float POPSTATS::statval() const {
  // @@protoc_insertion_point(field_get:pb.POPSTATS.statVal)
  return statval_;
}
inline void POPSTATS::set_statval(float value) {
  set_has_statval();
  statval_ = value;
  // @@protoc_insertion_point(field_set:pb.POPSTATS.statVal)
}

// -------------------------------------------------------------------

// POPINDICES

// required fixed32 nEvents = 1;
inline bool POPINDICES::has_nevents() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void POPINDICES::set_has_nevents() {
  _has_bits_[0] |= 0x00000001u;
}
inline void POPINDICES::clear_has_nevents() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void POPINDICES::clear_nevents() {
  nevents_ = 0u;
  clear_has_nevents();
}
inline ::google::protobuf::uint32 POPINDICES::nevents() const {
  // @@protoc_insertion_point(field_get:pb.POPINDICES.nEvents)
  return nevents_;
}
inline void POPINDICES::set_nevents(::google::protobuf::uint32 value) {
  set_has_nevents();
  nevents_ = value;
  // @@protoc_insertion_point(field_set:pb.POPINDICES.nEvents)
}

// required .pb.ind_type indtype = 2;
inline bool POPINDICES::has_indtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void POPINDICES::set_has_indtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void POPINDICES::clear_has_indtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void POPINDICES::clear_indtype() {
  indtype_ = 0;
  clear_has_indtype();
}
inline ::pb::ind_type POPINDICES::indtype() const {
  // @@protoc_insertion_point(field_get:pb.POPINDICES.indtype)
  return static_cast< ::pb::ind_type >(indtype_);
}
inline void POPINDICES::set_indtype(::pb::ind_type value) {
  assert(::pb::ind_type_IsValid(value));
  set_has_indtype();
  indtype_ = value;
  // @@protoc_insertion_point(field_set:pb.POPINDICES.indtype)
}

// repeated fixed32 iInd = 3;
inline int POPINDICES::iind_size() const {
  return iind_.size();
}
inline void POPINDICES::clear_iind() {
  iind_.Clear();
}
inline ::google::protobuf::uint32 POPINDICES::iind(int index) const {
  // @@protoc_insertion_point(field_get:pb.POPINDICES.iInd)
  return iind_.Get(index);
}
inline void POPINDICES::set_iind(int index, ::google::protobuf::uint32 value) {
  iind_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.POPINDICES.iInd)
}
inline void POPINDICES::add_iind(::google::protobuf::uint32 value) {
  iind_.Add(value);
  // @@protoc_insertion_point(field_add:pb.POPINDICES.iInd)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
POPINDICES::iind() const {
  // @@protoc_insertion_point(field_list:pb.POPINDICES.iInd)
  return iind_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
POPINDICES::mutable_iind() {
  // @@protoc_insertion_point(field_mutable_list:pb.POPINDICES.iInd)
  return &iind_;
}

// repeated bool bInd = 4;
inline int POPINDICES::bind_size() const {
  return bind_.size();
}
inline void POPINDICES::clear_bind() {
  bind_.Clear();
}
inline bool POPINDICES::bind(int index) const {
  // @@protoc_insertion_point(field_get:pb.POPINDICES.bInd)
  return bind_.Get(index);
}
inline void POPINDICES::set_bind(int index, bool value) {
  bind_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.POPINDICES.bInd)
}
inline void POPINDICES::add_bind(bool value) {
  bind_.Add(value);
  // @@protoc_insertion_point(field_add:pb.POPINDICES.bInd)
}
inline const ::google::protobuf::RepeatedField< bool >&
POPINDICES::bind() const {
  // @@protoc_insertion_point(field_list:pb.POPINDICES.bInd)
  return bind_;
}
inline ::google::protobuf::RepeatedField< bool >*
POPINDICES::mutable_bind() {
  // @@protoc_insertion_point(field_mutable_list:pb.POPINDICES.bInd)
  return &bind_;
}

// -------------------------------------------------------------------

// nodeProperties

// required string thisName = 1;
inline bool nodeProperties::has_thisname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void nodeProperties::set_has_thisname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void nodeProperties::clear_has_thisname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void nodeProperties::clear_thisname() {
  if (thisname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thisname_->clear();
  }
  clear_has_thisname();
}
inline const ::std::string& nodeProperties::thisname() const {
  // @@protoc_insertion_point(field_get:pb.nodeProperties.thisName)
  return *thisname_;
}
inline void nodeProperties::set_thisname(const ::std::string& value) {
  set_has_thisname();
  if (thisname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thisname_ = new ::std::string;
  }
  thisname_->assign(value);
  // @@protoc_insertion_point(field_set:pb.nodeProperties.thisName)
}
inline void nodeProperties::set_thisname(const char* value) {
  set_has_thisname();
  if (thisname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thisname_ = new ::std::string;
  }
  thisname_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.nodeProperties.thisName)
}
inline void nodeProperties::set_thisname(const char* value, size_t size) {
  set_has_thisname();
  if (thisname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thisname_ = new ::std::string;
  }
  thisname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.nodeProperties.thisName)
}
inline ::std::string* nodeProperties::mutable_thisname() {
  set_has_thisname();
  if (thisname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thisname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.nodeProperties.thisName)
  return thisname_;
}
inline ::std::string* nodeProperties::release_thisname() {
  clear_has_thisname();
  if (thisname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = thisname_;
    thisname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void nodeProperties::set_allocated_thisname(::std::string* thisname) {
  if (thisname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete thisname_;
  }
  if (thisname) {
    set_has_thisname();
    thisname_ = thisname;
  } else {
    clear_has_thisname();
    thisname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.nodeProperties.thisName)
}

// repeated .pb.POPSTATS fjStats = 2;
inline int nodeProperties::fjstats_size() const {
  return fjstats_.size();
}
inline void nodeProperties::clear_fjstats() {
  fjstats_.Clear();
}
inline const ::pb::POPSTATS& nodeProperties::fjstats(int index) const {
  // @@protoc_insertion_point(field_get:pb.nodeProperties.fjStats)
  return fjstats_.Get(index);
}
inline ::pb::POPSTATS* nodeProperties::mutable_fjstats(int index) {
  // @@protoc_insertion_point(field_mutable:pb.nodeProperties.fjStats)
  return fjstats_.Mutable(index);
}
inline ::pb::POPSTATS* nodeProperties::add_fjstats() {
  // @@protoc_insertion_point(field_add:pb.nodeProperties.fjStats)
  return fjstats_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::POPSTATS >&
nodeProperties::fjstats() const {
  // @@protoc_insertion_point(field_list:pb.nodeProperties.fjStats)
  return fjstats_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::POPSTATS >*
nodeProperties::mutable_fjstats() {
  // @@protoc_insertion_point(field_mutable_list:pb.nodeProperties.fjStats)
  return &fjstats_;
}

// repeated .pb.POPSTATS fcStats = 3;
inline int nodeProperties::fcstats_size() const {
  return fcstats_.size();
}
inline void nodeProperties::clear_fcstats() {
  fcstats_.Clear();
}
inline const ::pb::POPSTATS& nodeProperties::fcstats(int index) const {
  // @@protoc_insertion_point(field_get:pb.nodeProperties.fcStats)
  return fcstats_.Get(index);
}
inline ::pb::POPSTATS* nodeProperties::mutable_fcstats(int index) {
  // @@protoc_insertion_point(field_mutable:pb.nodeProperties.fcStats)
  return fcstats_.Mutable(index);
}
inline ::pb::POPSTATS* nodeProperties::add_fcstats() {
  // @@protoc_insertion_point(field_add:pb.nodeProperties.fcStats)
  return fcstats_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::POPSTATS >&
nodeProperties::fcstats() const {
  // @@protoc_insertion_point(field_list:pb.nodeProperties.fcStats)
  return fcstats_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::POPSTATS >*
nodeProperties::mutable_fcstats() {
  // @@protoc_insertion_point(field_mutable_list:pb.nodeProperties.fcStats)
  return &fcstats_;
}

// required bool hidden = 4;
inline bool nodeProperties::has_hidden() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void nodeProperties::set_has_hidden() {
  _has_bits_[0] |= 0x00000008u;
}
inline void nodeProperties::clear_has_hidden() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void nodeProperties::clear_hidden() {
  hidden_ = false;
  clear_has_hidden();
}
inline bool nodeProperties::hidden() const {
  // @@protoc_insertion_point(field_get:pb.nodeProperties.hidden)
  return hidden_;
}
inline void nodeProperties::set_hidden(bool value) {
  set_has_hidden();
  hidden_ = value;
  // @@protoc_insertion_point(field_set:pb.nodeProperties.hidden)
}

// required .pb.POPINDICES indices = 5;
inline bool nodeProperties::has_indices() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void nodeProperties::set_has_indices() {
  _has_bits_[0] |= 0x00000010u;
}
inline void nodeProperties::clear_has_indices() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void nodeProperties::clear_indices() {
  if (indices_ != NULL) indices_->::pb::POPINDICES::Clear();
  clear_has_indices();
}
inline const ::pb::POPINDICES& nodeProperties::indices() const {
  // @@protoc_insertion_point(field_get:pb.nodeProperties.indices)
  return indices_ != NULL ? *indices_ : *default_instance_->indices_;
}
inline ::pb::POPINDICES* nodeProperties::mutable_indices() {
  set_has_indices();
  if (indices_ == NULL) indices_ = new ::pb::POPINDICES;
  // @@protoc_insertion_point(field_mutable:pb.nodeProperties.indices)
  return indices_;
}
inline ::pb::POPINDICES* nodeProperties::release_indices() {
  clear_has_indices();
  ::pb::POPINDICES* temp = indices_;
  indices_ = NULL;
  return temp;
}
inline void nodeProperties::set_allocated_indices(::pb::POPINDICES* indices) {
  delete indices_;
  indices_ = indices;
  if (indices) {
    set_has_indices();
  } else {
    clear_has_indices();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.nodeProperties.indices)
}

// required .pb.gate thisGate = 6;
inline bool nodeProperties::has_thisgate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void nodeProperties::set_has_thisgate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void nodeProperties::clear_has_thisgate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void nodeProperties::clear_thisgate() {
  if (thisgate_ != NULL) thisgate_->::pb::gate::Clear();
  clear_has_thisgate();
}
inline const ::pb::gate& nodeProperties::thisgate() const {
  // @@protoc_insertion_point(field_get:pb.nodeProperties.thisGate)
  return thisgate_ != NULL ? *thisgate_ : *default_instance_->thisgate_;
}
inline ::pb::gate* nodeProperties::mutable_thisgate() {
  set_has_thisgate();
  if (thisgate_ == NULL) thisgate_ = new ::pb::gate;
  // @@protoc_insertion_point(field_mutable:pb.nodeProperties.thisGate)
  return thisgate_;
}
inline ::pb::gate* nodeProperties::release_thisgate() {
  clear_has_thisgate();
  ::pb::gate* temp = thisgate_;
  thisgate_ = NULL;
  return temp;
}
inline void nodeProperties::set_allocated_thisgate(::pb::gate* thisgate) {
  delete thisgate_;
  thisgate_ = thisgate;
  if (thisgate) {
    set_has_thisgate();
  } else {
    clear_has_thisgate();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.nodeProperties.thisGate)
}

// -------------------------------------------------------------------

// treeNodes

// required .pb.nodeProperties node = 1;
inline bool treeNodes::has_node() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void treeNodes::set_has_node() {
  _has_bits_[0] |= 0x00000001u;
}
inline void treeNodes::clear_has_node() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void treeNodes::clear_node() {
  if (node_ != NULL) node_->::pb::nodeProperties::Clear();
  clear_has_node();
}
inline const ::pb::nodeProperties& treeNodes::node() const {
  // @@protoc_insertion_point(field_get:pb.treeNodes.node)
  return node_ != NULL ? *node_ : *default_instance_->node_;
}
inline ::pb::nodeProperties* treeNodes::mutable_node() {
  set_has_node();
  if (node_ == NULL) node_ = new ::pb::nodeProperties;
  // @@protoc_insertion_point(field_mutable:pb.treeNodes.node)
  return node_;
}
inline ::pb::nodeProperties* treeNodes::release_node() {
  clear_has_node();
  ::pb::nodeProperties* temp = node_;
  node_ = NULL;
  return temp;
}
inline void treeNodes::set_allocated_node(::pb::nodeProperties* node) {
  delete node_;
  node_ = node;
  if (node) {
    set_has_node();
  } else {
    clear_has_node();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.treeNodes.node)
}

// required fixed32 parent = 2;
inline bool treeNodes::has_parent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void treeNodes::set_has_parent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void treeNodes::clear_has_parent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void treeNodes::clear_parent() {
  parent_ = 0u;
  clear_has_parent();
}
inline ::google::protobuf::uint32 treeNodes::parent() const {
  // @@protoc_insertion_point(field_get:pb.treeNodes.parent)
  return parent_;
}
inline void treeNodes::set_parent(::google::protobuf::uint32 value) {
  set_has_parent();
  parent_ = value;
  // @@protoc_insertion_point(field_set:pb.treeNodes.parent)
}

// -------------------------------------------------------------------

// populationTree

// repeated .pb.treeNodes node = 1;
inline int populationTree::node_size() const {
  return node_.size();
}
inline void populationTree::clear_node() {
  node_.Clear();
}
inline const ::pb::treeNodes& populationTree::node(int index) const {
  // @@protoc_insertion_point(field_get:pb.populationTree.node)
  return node_.Get(index);
}
inline ::pb::treeNodes* populationTree::mutable_node(int index) {
  // @@protoc_insertion_point(field_mutable:pb.populationTree.node)
  return node_.Mutable(index);
}
inline ::pb::treeNodes* populationTree::add_node() {
  // @@protoc_insertion_point(field_add:pb.populationTree.node)
  return node_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::treeNodes >&
populationTree::node() const {
  // @@protoc_insertion_point(field_list:pb.populationTree.node)
  return node_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::treeNodes >*
populationTree::mutable_node() {
  // @@protoc_insertion_point(field_mutable_list:pb.populationTree.node)
  return &node_;
}

// -------------------------------------------------------------------

// GatingHierarchy

// required .pb.populationTree tree = 2;
inline bool GatingHierarchy::has_tree() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GatingHierarchy::set_has_tree() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GatingHierarchy::clear_has_tree() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GatingHierarchy::clear_tree() {
  if (tree_ != NULL) tree_->::pb::populationTree::Clear();
  clear_has_tree();
}
inline const ::pb::populationTree& GatingHierarchy::tree() const {
  // @@protoc_insertion_point(field_get:pb.GatingHierarchy.tree)
  return tree_ != NULL ? *tree_ : *default_instance_->tree_;
}
inline ::pb::populationTree* GatingHierarchy::mutable_tree() {
  set_has_tree();
  if (tree_ == NULL) tree_ = new ::pb::populationTree;
  // @@protoc_insertion_point(field_mutable:pb.GatingHierarchy.tree)
  return tree_;
}
inline ::pb::populationTree* GatingHierarchy::release_tree() {
  clear_has_tree();
  ::pb::populationTree* temp = tree_;
  tree_ = NULL;
  return temp;
}
inline void GatingHierarchy::set_allocated_tree(::pb::populationTree* tree) {
  delete tree_;
  tree_ = tree;
  if (tree) {
    set_has_tree();
  } else {
    clear_has_tree();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.GatingHierarchy.tree)
}

// -------------------------------------------------------------------

// ghPair

// required .pb.GatingHierarchy gh = 1;
inline bool ghPair::has_gh() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ghPair::set_has_gh() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ghPair::clear_has_gh() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ghPair::clear_gh() {
  if (gh_ != NULL) gh_->::pb::GatingHierarchy::Clear();
  clear_has_gh();
}
inline const ::pb::GatingHierarchy& ghPair::gh() const {
  // @@protoc_insertion_point(field_get:pb.ghPair.gh)
  return gh_ != NULL ? *gh_ : *default_instance_->gh_;
}
inline ::pb::GatingHierarchy* ghPair::mutable_gh() {
  set_has_gh();
  if (gh_ == NULL) gh_ = new ::pb::GatingHierarchy;
  // @@protoc_insertion_point(field_mutable:pb.ghPair.gh)
  return gh_;
}
inline ::pb::GatingHierarchy* ghPair::release_gh() {
  clear_has_gh();
  ::pb::GatingHierarchy* temp = gh_;
  gh_ = NULL;
  return temp;
}
inline void ghPair::set_allocated_gh(::pb::GatingHierarchy* gh) {
  delete gh_;
  gh_ = gh;
  if (gh) {
    set_has_gh();
  } else {
    clear_has_gh();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.ghPair.gh)
}

// required string sampleName = 2;
inline bool ghPair::has_samplename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ghPair::set_has_samplename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ghPair::clear_has_samplename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ghPair::clear_samplename() {
  if (samplename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    samplename_->clear();
  }
  clear_has_samplename();
}
inline const ::std::string& ghPair::samplename() const {
  // @@protoc_insertion_point(field_get:pb.ghPair.sampleName)
  return *samplename_;
}
inline void ghPair::set_samplename(const ::std::string& value) {
  set_has_samplename();
  if (samplename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    samplename_ = new ::std::string;
  }
  samplename_->assign(value);
  // @@protoc_insertion_point(field_set:pb.ghPair.sampleName)
}
inline void ghPair::set_samplename(const char* value) {
  set_has_samplename();
  if (samplename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    samplename_ = new ::std::string;
  }
  samplename_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.ghPair.sampleName)
}
inline void ghPair::set_samplename(const char* value, size_t size) {
  set_has_samplename();
  if (samplename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    samplename_ = new ::std::string;
  }
  samplename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.ghPair.sampleName)
}
inline ::std::string* ghPair::mutable_samplename() {
  set_has_samplename();
  if (samplename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    samplename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.ghPair.sampleName)
  return samplename_;
}
inline ::std::string* ghPair::release_samplename() {
  clear_has_samplename();
  if (samplename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = samplename_;
    samplename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ghPair::set_allocated_samplename(::std::string* samplename) {
  if (samplename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete samplename_;
  }
  if (samplename) {
    set_has_samplename();
    samplename_ = samplename;
  } else {
    clear_has_samplename();
    samplename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.ghPair.sampleName)
}

// -------------------------------------------------------------------

// GatingSet

// repeated .pb.ghPair ghs = 1;
inline int GatingSet::ghs_size() const {
  return ghs_.size();
}
inline void GatingSet::clear_ghs() {
  ghs_.Clear();
}
inline const ::pb::ghPair& GatingSet::ghs(int index) const {
  // @@protoc_insertion_point(field_get:pb.GatingSet.ghs)
  return ghs_.Get(index);
}
inline ::pb::ghPair* GatingSet::mutable_ghs(int index) {
  // @@protoc_insertion_point(field_mutable:pb.GatingSet.ghs)
  return ghs_.Mutable(index);
}
inline ::pb::ghPair* GatingSet::add_ghs() {
  // @@protoc_insertion_point(field_add:pb.GatingSet.ghs)
  return ghs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::ghPair >&
GatingSet::ghs() const {
  // @@protoc_insertion_point(field_list:pb.GatingSet.ghs)
  return ghs_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::ghPair >*
GatingSet::mutable_ghs() {
  // @@protoc_insertion_point(field_mutable_list:pb.GatingSet.ghs)
  return &ghs_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::pb::ind_type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::ind_type>() {
  return ::pb::ind_type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_GatingSet_2eproto__INCLUDED
