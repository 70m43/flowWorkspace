setMethod("add",
		signature=c(wf="GatingSet", "list"),
		definition=function(wf, action, ...)
		{
			
			flist<-filterList(action)
			add(wf,flist,...)
			
		})
setMethod("add",
		signature=c("GatingSetInternal", "filterList"),
		definition=function(wf, action, ...)
		{
			samples<-getSamples(wf)
			
			if(!setequal(names(action),samples))
				stop("names of filterList do not match with the sample names in the gating set!")			
			
			nodeIDs<-lapply(samples,function(sample){
								curFilter<-action[[sample]]
								gh<-wf[[sample]]
#								browser()
								add(wf=gh,action=curFilter,...)
							})
					
			nodeID<-nodeIDs[[1]]
		
		if(!all(sapply(nodeIDs[-1],function(x)identical(x,nodeID))))
			stop("nodeID are not identical across samples!")
		
		nodeID
			
		})
setMethod("add",
		signature=c("GatingSetInternal", "filter"),
		definition=function(wf, action, ...)
		{
			
			message("replicating filter '",identifier(action),"' across samples!")
			
			actions<-sapply(getSamples(wf),function(x)return(action))
			add(wf,actions,...)
			
		})
.addGate<-function(gh,filterObject,parent=NULL, name=NULL,negated=FALSE){

	if(is.null(name))
		name<-filterObject$filterId
#	browser()
	##get node ID
	nodes<-getNodes(gh)
	if(is.null(parent))
		pid<-1
	else
	{
		if(is.numeric(parent))
			pid<-parent
		else
			pid<-match(parent,getNodes(gh))
		if(is.na(pid)||length(pid)==0)
			stop(parent," not found in gating tree")
	}
	filterObject$negated<-negated
#	browser()	
	nodeID<-.Call("R_addGate",gh@pointer,getSample(gh),filterObject,as.integer(pid-1),name)
	nodeID+1
}
setMethod("add",
		signature=c("GatingHierarchyInternal", "rectangleGate"),
		definition=function(wf, action,... )
		{
#			browser()
			
			params<-parameters(action)
			
			if(length(params)==1)
			{
				#convert to rangeGate
				filterObject<-list(type=as.integer(2)
									,params=params
									,range=c(action@min,action@max)	
									,filterId=action@filterId
									)
				
			}else
			{
				#convert to polygon gate
				mat<-rbind(action@min,action@max)
				filterObject<-list(type=as.integer(5)
						,params=params
						,boundaries=mat
						,filterId=action@filterId)	
			}
			
			.addGate(wf,filterObject,...)
				
			
		})

setMethod("add",
		signature=c("GatingHierarchyInternal", "polygonGate"),
		definition=function(wf, action, ...)
		{

			
#			browser()
			params<-parameters(action)
			
			filterObject<-list(type=as.integer(1)
								,params=params
								,boundaries=action@boundaries
								,filterId=action@filterId)	
		
			.addGate(wf,filterObject,...)
		})
setMethod("add",
		signature=c("GatingHierarchyInternal", "booleanFilter"),
		definition=function(wf, action, ...)
		{
			
			
#			browser()
			expr<-action@deparse
			pattern<-"&|\\|"
			#get the position of logical operators
			op_ind<-unlist(gregexpr(pattern=pattern,expr))
			#extract these operators
			op<-trimWhiteSpace(substring(expr,op_ind,op_ind))
			##append & for the first node element(as C parser convention requires)
			op<-c("&",op)
			#split into node elements by operators
			refs<-unlist(strsplit(expr,split=pattern)) 
			refs<-trimWhiteSpace(refs)
			#extract is not operator
			isNot<-as.logical(regexpr("!",refs)+1) 
			#strip is not operator from node elements
			refs<-gsub("!","",refs)
			
			nNodes<-length(refs)
			if(length(isNot)!=nNodes)
				stop("the number of ! operators are inconsistent with nodes!")
			if(length(op)!=nNodes)
				stop("the number of logical operators are inconsistent with nodes!")
			filterObject<-list(type=as.integer(3)
								,refs=refs
								,isNot=isNot
								,op=op
								,filterId=action@filterId)	
#						browser()
			.addGate(wf,filterObject,...)
		})
setMethod("add",
		signature=c("GatingHierarchyInternal", "quadGate"),
		definition=function(wf, action,names=NULL,... )
		{
			
			#convert to four recgates			
			params<-parameters(action)
			pd<-pData(parameters(getData(wf)))
			desc<-sapply(params,function(x)flowWorkspace:::.getChannelMarker(pd,x)$des)
			
			v <- action@boundary[params[1]]
			h <- action@boundary[params[2]]
			mat <- matrix(c(-Inf, v, h, Inf
							, v, Inf, h, Inf
							, v, Inf, -Inf, h
							, -Inf, v, -Inf,h
							)
						, byrow=TRUE
						, ncol=4)              
			#clock-wise from top left quadrant
			if(is.null(names))
				names <- matrix(c(sprintf("%s-%s+", desc[1], desc[2]),
									sprintf("%s+%s+", desc[1], desc[2]),
									sprintf("%s+%s-", desc[1], desc[2]),
									sprintf("%s-%s-", desc[1], desc[2])
									),
								ncol=2)
			if(length(unique(names))!=4)
				stop("names have to be four unique strings!")
			unlist(lapply(1:4,function(i){
#								browser()
							rg <- rectangleGate(.gate=matrix(mat[i,], ncol=2,
											dimnames=list(c("min", "max"), params))
											,filterId=names[i])
							add(wf,rg,...)
						})
					)
			
			
			
		})
##TODO:Either to create a speical logicalGate derived from "filter"
## that just contains the logical vector as indices generated by other algrorithm 
## like flowClust..
## Or we could try to use filterResult and filterResultList from flowCore
## to save the efforts of adding new filter type, but the extra contructor is necessary to 
## convert logical vector to filterResult.
#setMethod("add",
#		signature=c("GatingHierarchyInternal", "logicalGate"),
#		definition=function(wf, action, name,...)
#		{
#			
#			
##			browser()
#			if(missing(name))
#				stop("population name is required!")
#			if(length(action)!=nrow(getData(wf)))
#				stop("the length of logical vector is different from events number in: ",getSample(wf))
#			
#			
#			filterObject<-list(type=as.integer(6)
#								,indices=action
#								)	
#			
#			.addGate(wf,filterObject,...)
#		})

setMethod("Rm",
		signature=c(symbol="character",
				envir="GatingSetInternal",
				subSymbol="character"),
		definition=function(symbol, envir, subSymbol, ...)
		{
			invisible(lapply(envir,function(gh){
#								browser()
								Rm(symbol,gh,subSymbol,...)
							}))
		})

setMethod("Rm",
		signature=c(symbol="character",
				envir="GatingHierarchyInternal",
				subSymbol="character"),
		definition=function(symbol, envir, subSymbol, ...)
		{
#			browser()
			##remove all children nodes as well
			childrenNodes<-getChildren(envir,symbol)
			lapply(childrenNodes,function(child)Rm(child,envir))
			
			nid<-match(symbol,getNodes(envir))
			if(length(nid)==0)
				stop(symbol," not found in gating tree")
			.Call("R_removeNode",envir@pointer,getSample(envir),nid-1)
		})
#construct a gatingset with empty trees (just root node) 
setMethod("GatingSet",c("flowSet"),function(x,dMode=0,...){
			
			
			samples<-sampleNames(x)
			G<-new("GatingSetInternal")
			G@pointer<-.Call("R_NewGatingSet_rootOnly",samples,dMode=as.integer(dMode))
			
			
			globalDataEnv<-new.env(parent=emptyenv())
			
			assign("ncfs",x,globalDataEnv)
#			nFiles<-length(samples)
#			set<-vector(mode="list",nFiles)	
#
#			for(i in 1:nFiles)
#			{
#				file<-files[i]		
#				sampleName<-samples[i]
#				gh<-new("GatingHierarchyInternal",pointer=G@pointer,name=sampleName)
##			browser()
#				localDataEnv<-nodeDataDefaults(gh@tree,"data")
#				localDataEnv$data<-globalDataEnv
#				
#				gh@flag<-FALSE #set gate flag
#				set[[i]]<-gh
#			}
#			names(set)<-samples
#			G@set<-set
						
			G@set<-sapply(samples,function(sampleName){
						gh<-new("GatingHierarchyInternal",pointer=G@pointer,name=sampleName)
						localDataEnv<-nodeDataDefaults(gh@tree,"data")
						localDataEnv$data<-globalDataEnv
						gh@flag<-TRUE #set gate flag
						gh
					})
			recompute(G)
			G
			
		})
