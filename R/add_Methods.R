#' @include filterObject_Methods.R
NULL

#' @templateVar old add
#' @templateVar new gs_add_gate
#' @template template-depr_pkg
NULL

#' Create a GatingSet and add/remove the flowCore gate(or population) to/from a GatingHierarchy/GatingSet.
#' 
#' \code{GatingSet} method creates a gatingset from a flowSet with the ungated data as the root node.
#' \code{add} method add the flowCore gate to a GatingHierarchy/GatingSet.
#' \code{gs_set_gate} method update the gate of one population node in GatingHierarchy/GatingSet.
#' \code{Rm} method Remove the population node from a GatingHierarchy/GatingSet. 
#' They are equivalent to the \code{workFlow},\code{add} and \code{Rm} methods in \code{flowCore} package. 
#' \code{recompute} method does the actual gating after the gate is added,i.e. calculating the event indices according to the gate definition.   
#' @param wf A \code{GatingHierrarchy} or \code{GatingSet}
#' @param envir A \code{GatingHierrarchy} or \code{GatingSet}
#' @param action A \code{filter} or a list of \code{filter}s to be added to the  \code{GatingHierarchy} or \code{GatingSet}.
#' @param names  a \code{character} vector of length four,which specifies the population names resulted by adding a \code{quadGate}.
#' @param parent a \code{character} scalar to specify the parent node name where the new gate to be added to, by default it is NULL,which indicates the root node
#' @param name a \code{character} scalar to specify the node name of population that is generated by the gate to be added.
#' @param recompute a \code{logical} flag
#' The order of the names is clock-wise starting from the top left quadrant population.
#' @param ... some other arguments to specify how the gates are added to the gating tree.
#' \itemize{
#'       \item negated: a \code{logical} scalar to specify whether the gate is negated,which means the the population outside of the gate will be kept as the result population.
#'       It is FALSE by default. 
#'  }
#' @param symbol A \code{character} identifies the population node in a \code{GatingHierrarchy} or \code{GatingSet} to remove
#' @param subSymbol Not used.
#' @return 
#'   \code{GatingSet} method returns a \code{GatingSet} object with just root node.  
#'   \code{add} method returns a population node ID (or four population node IDs when adding a \code{quadGate}) that uniquely identify the population node within a  \code{GatingHierarchy}.
#' @seealso \code{\link{GatingSet-class}}
#' @examples
#' \dontrun{
#'     data(GvHD)
#' #select raw flow data
#'     fs<-GvHD[1:3]
#'     
#' #transform the raw data
#'     tf <- transformList(colnames(fs[[1]])[3:6], asinh, transformationId="asinh")
#'     fs_trans<-transform(fs,tf)
#'     
#' #add transformed data to a gatingset
#'     gs <- GatingSet(fs_trans)
#'     gs
#'     gs_get_pop_paths(gs[[1]]) #only contains root node
#'     
#' #add one gate
#'     rg <- rectangleGate("FSC-H"=c(200,400), "SSC-H"=c(250, 400),
#'         filterId="rectangle")
#'     
#'     nodeID<-gs_add_gate(gs, rg)#it is added to root node by default if parent is not specified
#'     nodeID
#'     gs_get_pop_paths(gs[[1]]) #the second population is named after filterId of the gate 
#'     
#' #add a quadGate
#'     qg <- quadGate("FL1-H"=2, "FL2-H"=4)
#'     nodeIDs<-gs_add_gate(gs,qg,parent="rectangle")
#'     nodeIDs #quadGate produces four population nodes
#'     gs_get_pop_paths(gs[[1]]) #population names are named after dimensions of gate if not specified
#'     
#' #add a boolean Gate
#'     bg<-booleanFilter(`CD15 FITC-CD45 PE+`|`CD15 FITC+CD45 PE-`)
#'     bg
#'     nodeID2<-gs_add_gate(gs,bg,parent="rectangle")
#'     nodeID2
#'     gs_get_pop_paths(gs[[1]])
#' #do the actual gating
#'     recompute(gs)
#'     
#' #plot one gate for one sample
#'     plotGate(gs[[1]],"rectangle")
#'     plotGate(gs[[1]],nodeIDs) #may be smoothed automatically if there are not enough events after gating
#'     
#' #plot gates across samples using lattice plot
#'     plotGate(gs,nodeID)
#' #plot all gates for one sample
#'     plotGate(gs[[1]])#boolean gate is skipped by default 
#'     plotGate(gs[[1]],bool=TRUE)
#'     
#' #plot the gating hierarchy
#'     plot(gs[[1]])
#' #remove one node causing the removal of all the descendants 
#'     gs_remove_gate('rectangle', gs)
#'     gs_get_pop_paths(gs[[1]])
#'  }
#' @export 
#' @rdname add
#' @aliases
#' add
#' Rm
#' @param validityCheck \code{logical} whether to check the consistency of tree structure across samples. default is TRUE. Can be turned off when speed is prefered to the robustness.
add <- function(wf, action,...)UseMethod("add")
#' @export 
#' @rdname add
add.default <- function(wf, action,...)
		{
			.Deprecated("gs_add_gate")
			gs_add_gate(wf, action, ...)
			
		}
#' @export 
#' @rdname add
gs_add_gate <- function(wf, action, validityCheck = TRUE, ...){
  
  samples <- sampleNames(wf)
  if((is(action, "filter")||is(action, "filters")) && !is(action, "filterResultList"))
    action <- sapply(samples,function(x)return(action))
  
  if(!setequal(names(action),samples))
    stop("names of gate list do not match with the sample names in the gating set!")			
  
  nodeIDs <- lapply(samples,function(sample){
    curFilter <- action[[sample]]
    gh <- wf[[sample]]
    #								browser()
    gh_add_gate(wf = gh, action = curFilter, ...)
  })
  
  nodeID <- nodeIDs[[1]]
  
  if(validityCheck){
    if(!all(sapply(nodeIDs[-1],function(x)isTRUE(all.equal(x, nodeID, check.attributes = FALSE))))){
      #restore the gatingset by removing added nodes
      mapply(samples, nodeIDs, FUN = function(sample, nodeID){
        gh <- wf[[sample]]
        nodes <- gs_get_pop_paths(gh)[nodeID]
        lapply(nodes, gh_remove_gate, envir = gh)
      })
      stop("nodeID are not identical across samples!")
    }
    
  }
  nodeID
}

 
#' @param recompute \code{logical} whether to recompute the event indices right after gate is added. 
#'                                  Oftentimes it is more efficient to let user to determining how and when the flow data is loaded
#'                                  Thus default it FALSE.                      
.addGate <- function(gh, filterObject, parent = "root", name = NULL, negated = FALSE, recompute = FALSE){
  
	if(is.null(name))
		name <- filterObject$filterId
    #replace the slash with colon 
    #since forward slash is reserved for gating path
  if(grepl("/",name)){
    old_name <- name
    name <- gsub("/",":",name)
    warning(old_name, " is replaced with ", name)
  }
    
	
	
	filterObject$negated <- negated
#	browser()	
    sn <- sampleNames(gh)
    
    ptr <- gh@pointer
	nodeID <- .cpp_addGate( ptr, sn, filterObject, parent, name)

    if(recompute){
      extend_val <- 0
      ignore_case <- FALSE
      gains <- numeric(0)
      #this always load the raw data
      #which may not be optimal for bool gate
      data <- gh_get_data(gh)
      mat <- exprs(data)
      .cpp_gating( ptr, mat,sn,gains,nodeID,recompute,extend_val, ignore_case, TRUE, 1)
    }
        
	nodeID+1
}

gh_add_gate <- function(wf, action, ... ){
  if(is(action, "quadGate"))
    gh_add_quadGate(wf, action, ...)
  else if(is(action, "filters"))
    gh_add_filters(wf, action, ...)
  else if(is(action, "logical"))
    gh_add_logical(wf, action, ...)
  else if(is(action, "factor"))
    gh_add_factor(wf, action, ...)
  else if(is(action, "logicalFilterResult"))
    gh_add_logicalFilterResult(wf, action, ...)
  else if(is(action, "multipleFilterResult"))
    gh_add_multipleFilterResult(wf, action, ...)
  else if(is(action, "filter"))
    gh_add_filter(wf, action, ...)
  else
    stop("can't add ", class(action))
}

gh_add_filter <- function(wf, action,... )
		{
			.addGate(wf,filter_to_list(action),...)
		}
    
gh_add_filters <- function(wf, action, names = NULL, ... )
    {
      if(!is.null(names))
      {
        if(any(duplicated(names)))
          stop("population names given by 'name` argument are not unqiue")
        if(length(names)!=length(action))
          stop("number of population names (given by 'name' argument) does not agree with the number of filter objects in 'filters'!")
        
        unlist(mapply(action, names, FUN = function(thisFilter, thisName){
          gh_add_filter(wf,thisFilter, name = thisName, ...)
                })
        )
      }else
        unlist(lapply(action, function(thisFilter)gh_add_filter(wf, thisFilter,...)))
      
    }

gh_add_quadGate <- function(wf, action, names = NULL, ... )
		{
			
			#convert to four recgates			
			params<-parameters(action)
			fr <- gh_get_data(wf, use.exprs = FALSE)
			desc<-sapply(params,function(x)getChannelMarker(fr,x)$des)
			
			v <- action@boundary[params[1]]
			h <- action@boundary[params[2]]
			mat <- matrix(c(-Inf, v, h, Inf
							, v, Inf, h, Inf
							, v, Inf, -Inf, h
							, -Inf, v, -Inf,h
							)
						, byrow=TRUE
						, ncol=4)              
			#clock-wise from top left quadrant
			if(is.null(names))
				names <- matrix(c(sprintf("%s-%s+", desc[1], desc[2]),
									sprintf("%s+%s+", desc[1], desc[2]),
									sprintf("%s+%s-", desc[1], desc[2]),
									sprintf("%s-%s-", desc[1], desc[2])
									),
								ncol=2)
			if(length(unique(names))!=4)
				stop("names have to be four unique strings!")
			unlist(lapply(1:4,function(i){
#								browser()
							rg <- rectangleGate(.gate=matrix(mat[i,], ncol=2,
											dimnames=list(c("min", "max"), params))
											,filterId=names[i])
							gh_add_filter(wf,rg,...)
						})
					)
			
			
			
		}


## it just contains the logical vector as indices generated by clustering algrorithm 
## like flowClust

#' @param cluster_method_name when adding the logical vectors as the gates, the name of the cluster method can be used to tag the populations as the extra meta information associated with the gates.  
#' @noRd 
gh_add_logical <- function(wf, action, parent, name, recompute, cluster_method_name = NULL, ... )
          {
            
            
            ind <- action
            
            #convert to global one by combining it with parent indice
            pInd.logical <- gh_get_indices(wf, parent)
            # browser()
            #convert it to  global ind 
            if(length(ind) < length(pInd.logical))
            {
              pInd.int <- which(pInd.logical)
              if(length(ind) != length(pInd.int))
                stop("the length of  the logical indices ", length(ind), " does not match to the parent events number ", length(pInd.int))
              pInd.logical[pInd.int] <- ind
              ind <- pInd.logical
            }
              
            fb <- filter_to_list(ind)
            #update object when it is a clusterGate
            if(!is.null(cluster_method_name))
            {
              fb[["type"]] <- 8
              fb[["cluster_method_name"]] <- cluster_method_name
            }
            #skip gating by ignoring recompute      
            nodeID <- flowWorkspace:::.addGate(wf, fb, name = name, parent = parent, recompute = FALSE, ...)
            
            #added it to gating tree
            sn <- sampleNames(wf)
            ptr <- wf@pointer
            flowWorkspace:::.cpp_setIndices(ptr, sn, nodeID-1, ind)
          }

gh_add_factor <- function(wf, action, name = NULL, ...)
          {
            popNames <- levels(action)
            if(is.null(name))
              stop("Must specify the name of the cluster method through 'name' argument")
            else
            {
              if(length(name) != 1)
                stop("'name' can't use multiple!")
            }
            for(i in seq_along(popNames)){
              
              thisPop <- popNames[i]
              
              pop <- paste(name, thisPop, sep = "_")
              
              # browser()
              #convert it to logical
              ind <- action == thisPop
              ind[is.na(ind)] <- FALSE#in case there are some NA values in factor
              gh_add_logical(wf, ind, name = pop, cluster_method_name = name, ...)
            }
          }

gh_add_logicalFilterResult <- function(wf, action, ... )
          {
            
            #fetch the indices from the fitler result
            action <- action@subSet
            gh_add_logical(wf, action, ...)
            
          }

gh_add_multipleFilterResult <- function(wf, action, name = NULL, ...)
          {
            popNames <- names(action)
            if(!is.null(name)){
              if(length(name) != length(popNames))
                stop("name must be of the same length as the number of populations in multipleFilterResult!")
            }
            for(i in seq_along(popNames)){
              
              thisName <- name[i]
              thisPop <- popNames[i]
              if(is.null(thisName)){
                pop <- thisPop
              }else{
                pop <- thisName
              }
              gh_add_logicalFilterResult(wf, action[[pop]], name = pop, ...)
            }
          }

#' @templateVar old Rm
#' @templateVar new gs_remove_gate
#' @template template-depr_pkg
NULL
#' @export 
#' @rdname add
gs_remove_gate <- function(symbol, envir, ...){
  invisible(lapply(envir,function(gh){
    #								browser()
    gh_remove_gate(symbol,gh,...)
  }))
}
#' @export 
#' @rdname add
setMethod("Rm",
		signature=c(symbol="character",
				envir="GatingSet"),
		definition=function(symbol, envir, ...)
		{
			.Deprecated("gs_remove_gate")
		  gs_remove_gate(symbol, envir, ...)
		})
#' @export 
#' @rdname add    
setMethod("Rm",
    signature=c(symbol="character",
        envir="GatingSetList",
        subSymbol="character"),
    definition=function(symbol, envir, subSymbol, ...)
    {
      selectMethod("Rm"
          ,signature = c(symbol="character", envir="GatingSet", subSymbol="character"))(symbol, envir, subSymbol, ...)
    })
    

gh_remove_gate <- function(symbol, envir, ...)
		{
            ##remove all children nodes as well
			childrenNodes <- gs_get_children(envir,symbol)
            #use path instead of unqiue name since the prefix of unique name
            #will change during deletion
			lapply(childrenNodes,function(child)gs_remove_gate(child,envir))
            
			.cpp_removeNode(envir@pointer,sampleNames(envir), symbol)
		}


    
