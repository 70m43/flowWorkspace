#' @include filterObject_Methods.R
NULL


#' Create a GatingSet and add/remove the flowCore gate(or population) to/from a GatingHierarchy/GatingSet.
#' 
#' \code{GatingSet} method creates a gatingset from a flowSet with the ungated data as the root node.
#' \code{add} method add the flowCore gate to a GatingHierarchy/GatingSet.
#' \code{setGate} method update the gate of one population node in GatingHierarchy/GatingSet.
#' \code{Rm} method Remove the population node from a GatingHierarchy/GatingSet. 
#' They are equivalent to the \code{workFlow},\code{add} and \code{Rm} methods in \code{flowCore} package. 
#' \code{recompute} method does the actual gating after the gate is added,i.e. calculating the event indices according to the gate definition.   
#' @param wf A \code{GatingHierrarchy} or \code{GatingSet}
#' @param envir A \code{GatingHierrarchy} or \code{GatingSet}
#' @param action A \code{filter} or a list of \code{filter}s to be added to the  \code{GatingHierarchy} or \code{GatingSet}.
#' @param names  a \code{character} vector of length four,which specifies the population names resulted by adding a \code{quadGate}.
#' @param parent a \code{character} scalar to specify the parent node name where the new gate to be added to, by default it is NULL,which indicates the root node
#' @param name a \code{character} scalar to specify the node name of population that is generated by the gate to be added.
#' @param recompute a \code{logical} flag
#' The order of the names is clock-wise starting from the top left quadrant population.
#' @param ... some other arguments to specify how the gates are added to the gating tree.
#' \itemize{
#'       \item negated: a \code{logical} scalar to specify whether the gate is negated,which means the the population outside of the gate will be kept as the result population.
#'       It is FALSE by default. 
#'  }
#' @param symbol A \code{character} identifies the population node in a \code{GatingHierrarchy} or \code{GatingSet} to remove
#' @param subSymbol Not used.
#' @return 
#'   \code{GatingSet} method returns a \code{GatingSet} object with just root node.  
#'   \code{add} method returns a population node ID (or four population node IDs when adding a \code{quadGate}) that uniquely identify the population node within a  \code{GatingHierarchy}.
#' @seealso \code{\link{GatingSet-class}}
#' @examples
#' \dontrun{
#'     data(GvHD)
#' #select raw flow data
#'     fs<-GvHD[1:3]
#'     
#' #transform the raw data
#'     tf <- transformList(colnames(fs[[1]])[3:6], asinh, transformationId="asinh")
#'     fs_trans<-transform(fs,tf)
#'     
#' #add transformed data to a gatingset
#'     gs <- GatingSet(fs_trans)
#'     gs
#'     getNodes(gs[[1]]) #only contains root node
#'     
#' #add one gate
#'     rg <- rectangleGate("FSC-H"=c(200,400), "SSC-H"=c(250, 400),
#'         filterId="rectangle")
#'     
#'     nodeID<-add(gs, rg)#it is added to root node by default if parent is not specified
#'     nodeID
#'     getNodes(gs[[1]]) #the second population is named after filterId of the gate 
#'     
#' #add a quadGate
#'     qg <- quadGate("FL1-H"=2, "FL2-H"=4)
#'     nodeIDs<-add(gs,qg,parent="rectangle")
#'     nodeIDs #quadGate produces four population nodes
#'     getNodes(gs[[1]]) #population names are named after dimensions of gate if not specified
#'     
#' #add a boolean Gate
#'     bg<-booleanFilter(`CD15 FITC-CD45 PE+`|`CD15 FITC+CD45 PE-`)
#'     bg
#'     nodeID2<-add(gs,bg,parent="rectangle")
#'     nodeID2
#'     getNodes(gs[[1]])
#' #do the actual gating
#'     recompute(gs)
#'     
#' #plot one gate for one sample
#'     autoplot(gs[[1]],"rectangle")
#'     autoplot(gs[[1]],nodeIDs) #may be smoothed automatically if there are not enough events after gating
#'     
#' #plot gates across samples using lattice plot
#'     autoplot(gs,nodeID)
#' #plot all gates for one sample
#'     autoplot(gs[[1]])#boolean gate is skipped by default 
#'     autoplot(gs[[1]],bool=TRUE)
#'     
#' #plot the gating hierarchy
#'     require(Rgraphviz)
#'     plot(gs[[1]])
#' #remove one node causing the removal of all the descendants 
#'     Rm('rectangle', gs)
#'     getNodes(gs[[1]])
#'  }
#' @export 
#' @rdname add
#' @aliases
#' add
#' Rm
setMethod("add",
		signature=c(wf="GatingSet", "list"),
		definition=function(wf, action, ...)
		{

            # if(all(sapply(action, function(i)extends(class(i), "filterResult")))){
              #dispatch right away to avoid the overhead 
              #since filterResult is expensive to be passed around
              id <- selectMethod("add", signature = c("GatingSet", "filterList"))(wf, action, ...)
              return(id)
#             }else if(all(sapply(action, function(i)extends(class(i), "filter"))))
# 			  flist <- filterList(action)
#             else if(all(sapply(action, function(i)extends(class(i), "filters"))))
#               flist <- filtersList(action)
#             else
#               stop ("the gate list doesn't constain valid 'filter', 'filters' or 'filterResult' objects!")
#             
			# add(wf,flist,...)
			
		})

#' @export 
#' @rdname add
setMethod("add",
    signature=c(wf="GatingSetList", "list"),
    definition=function(wf, action, ...)
    {
      
      selectMethod("add",signature = c(wf="GatingSet", action="list"))(wf, action, ...)
      
    })    
#' @export 
#' @rdname add
setMethod("add",
    signature=c("GatingSet", "filtersList"),
    definition=function(wf, action, ...)
    {
      selectMethod("add",signature = c(wf="GatingSet", action="filterList"))(wf, action, ...)
      
    })
    
#' @param validityCheck \code{logical} whether to check the consistency of tree structure across samples. default is TRUE. Can be turned off when speed is prefered to the robustness.
#' @export 
#' @rdname add
setMethod("add",
		signature=c("GatingSet", "filterList"),
		definition=function(wf, action, validityCheck = TRUE,...)
		{
			samples<-sampleNames(wf)
			
			if(!setequal(names(action),samples))
				stop("names of gate list do not match with the sample names in the gating set!")			
			
			nodeIDs <- lapply(samples,function(sample){
								curFilter <- action[[sample]]
								gh <- wf[[sample]]
#								browser()
								add(wf = gh, action = curFilter, ...)
							})
					
			nodeID <- nodeIDs[[1]]
            
        if(validityCheck){
          if(!all(sapply(nodeIDs[-1],function(x)isTRUE(all.equal(x, nodeID, check.attributes = FALSE))))){
            #restore the gatingset by removing added nodes
            mapply(samples, nodeIDs, FUN = function(sample, nodeID){
                  gh <- wf[[sample]]
                  nodes <- getNodes(gh)[nodeID]
                  lapply(nodes, Rm, envir = gh)
                })
            stop("nodeID are not identical across samples!")
          }
          
        }
		nodeID
			
		})
    
#' @export 
#' @rdname add
setMethod("add",
        signature=c("GatingSetList", "filterList"),
        definition=function(wf, action, ...)
        {
          selectMethod("add",signature = c(wf="GatingSet", action="filterList"))(wf, action, ...)
        })
    
#' @export 
#' @rdname add
setMethod("add",
    signature=c("GatingSetList", "filtersList"),
    definition=function(wf, action, ...)
    {
      selectMethod("add",signature = c(wf="GatingSet", action="filtersList"))(wf, action, ...)
    })
#' @export 
#' @rdname add
setMethod("add",
		signature=c("GatingSet", "filter"),
		definition=function(wf, action, ...)
		{
			
			message("replicating filter '",identifier(action),"' across samples!")
			
			actions<-sapply(sampleNames(wf),function(x)return(action))
			add(wf,actions,...)
			
		})
#' @export 
#' @rdname add    
setMethod("add",
    signature=c("GatingSet", "filters"),
    definition=function(wf, action, ...)
    {
      
      message("replicating filters '",identifier(action),"' across samples!")
      
      actions <- sapply(sampleNames(wf),function(x)return(action))
      add(wf,actions,...)
      
    })    
#' @export 
#' @rdname add
setMethod("add",
    signature=c("GatingSetList", "filter"),
    definition=function(wf, action, ...)
    {
      
      selectMethod("add",signature = c(wf="GatingSet", action="filter"))(wf, action, ...)
      
    })
#' @export 
#' @rdname add
setMethod("add",
    signature=c("GatingSetList", "filters"),
    definition=function(wf, action, ...)
    {
      
      selectMethod("add",signature = c(wf="GatingSet", action="filters"))(wf, action, ...)
      
    })


#' @rdname add                                                       
.addGate <- function(gh, filterObject, parent = "root", name = NULL, negated = FALSE){
  
	if(is.null(name))
		name <- filterObject$filterId
    #replace the slash with colon 
    #since forward slash is reserved for gating path
  if(grepl("/",name)){
    old_name <- name
    name <- gsub("/",":",name)
    warning(old_name, " is replaced with ", name)
  }
    
	
	
	filterObject$negated <- negated
#	browser()	
    sn <- sampleNames(gh)
    
    ptr <- gh@pointer
	nodeID <- .cpp_addGate( ptr, sn, filterObject, parent, name)
        
	nodeID+1
}

#' @export 
#' @rdname add
setMethod("add",
		signature=c("GatingHierarchy", "filter"),
		definition=function(wf, action,... )
		{
			
			.addGate(wf,filterObject(action),...)
		})
    
#' @export 
#' @rdname add
setMethod("add",
    signature=c("GatingHierarchy", "filters"),
    definition=function(wf, action, names = NULL, ... )
    {
      if(!is.null(names))
      {
        if(any(duplicated(names)))
          stop("population names given by 'name` argument are not unqiue")
        if(length(names)!=length(action))
          stop("number of population names (given by 'name' argument) does not agree with the number of filter objects in 'filters'!")
        
        unlist(mapply(action, names, FUN = function(thisFilter, thisName){
                  add(wf,thisFilter, name = thisName, ...)
                })
        )
      }else
        unlist(lapply(action, function(thisFilter)add(wf, thisFilter,...)))
      
    })
#' @export 
#' @rdname add
setMethod("add",
		signature=c("GatingHierarchy", "quadGate"),
		definition=function(wf, action, names = NULL, ... )
		{
			
			#convert to four recgates			
			params<-parameters(action)
			fr <- getData(wf, use.exprs = FALSE)
			desc<-sapply(params,function(x)getChannelMarker(fr,x)$des)
			
			v <- action@boundary[params[1]]
			h <- action@boundary[params[2]]
			mat <- matrix(c(-Inf, v, h, Inf
							, v, Inf, h, Inf
							, v, Inf, -Inf, h
							, -Inf, v, -Inf,h
							)
						, byrow=TRUE
						, ncol=4)              
			#clock-wise from top left quadrant
			if(is.null(names))
				names <- matrix(c(sprintf("%s-%s+", desc[1], desc[2]),
									sprintf("%s+%s+", desc[1], desc[2]),
									sprintf("%s+%s-", desc[1], desc[2]),
									sprintf("%s-%s-", desc[1], desc[2])
									),
								ncol=2)
			if(length(unique(names))!=4)
				stop("names have to be four unique strings!")
			unlist(lapply(1:4,function(i){
#								browser()
							rg <- rectangleGate(.gate=matrix(mat[i,], ncol=2,
											dimnames=list(c("min", "max"), params))
											,filterId=names[i])
							add(wf,rg,...)
						})
					)
			
			
			
		})


## it just contains the logical vector as indices generated by clustering algrorithm 
## like flowClust

#' @export 
#' @rdname add
setMethod("add",
          signature=c("GatingHierarchy", "logical"),
          definition=function(wf, action, parent, name, recompute, cluster_method_name = NULL, ... )
          {
            
            
            ind <- action
            
            #convert to global one by combining it with parent indice
            pInd.logical <- getIndices(wf, parent)
            # browser()
            #convert it to  global ind 
            if(length(ind) < length(pInd.logical))
            {
              pInd.int <- which(pInd.logical)
              if(length(ind) != length(pInd.int))
                stop("the length of  the logical indices ", length(ind), " does not match to the parent events number ", length(pInd.int))
              pInd.logical[pInd.int] <- ind
              ind <- pInd.logical
            }
              
            fb <- filterObject(ind)
            #update object when it is a clusterGate
            if(!is.null(cluster_method_name))
            {
              fb[["type"]] <- 8
              fb[["cluster_method_name"]] <- cluster_method_name
            }
            #skip gating by ignoring recompute      
            nodeID <- .addGate(wf, fb, name = name, parent = parent, ...)
            
            #added it to gating tree
            sn <- sampleNames(wf)
            ptr <- wf@pointer
            flowWorkspace:::.cpp_setIndices(ptr, sn, nodeID-1, ind)
          })

#' @export 
#' @rdname add
setMethod("add",
          signature=c("GatingHierarchy", "factor"),
          definition=function(wf, action, name = NULL, ...)
          {
            popNames <- levels(action)
            if(is.null(name))
              stop("Must specify the name of the cluster method through 'name' argument")
            else
            {
              if(length(name) != 1)
                stop("'name' can't use multiple!")
            }
            for(i in seq_along(popNames)){
              
              thisPop <- popNames[i]
              
              pop <- paste(name, thisPop, sep = "_")
              
              # browser()
              #convert it to logical
              ind <- action == thisPop
              ind[is.na(ind)] <- FALSE#in case there are some NA values in factor
              add(wf, ind, name = pop, cluster_method_name = name, ...)
            }
          })

#' @export 
#' @rdname add
setMethod("add",
          signature=c("GatingHierarchy", "logicalFilterResult"),
          definition=function(wf, action, ... )
          {
            
            #fetch the indices from the fitler result
            action <- action@subSet
            selectMethod("add",signature = c(wf="GatingHierarchy", action="logical"))(wf, action, ...)
            
          })

#' @export 
#' @rdname add
setMethod("add",
          signature=c("GatingHierarchy", "multipleFilterResult"),
          definition=function(wf, action, name = NULL, ...)
          {
            popNames <- names(action)
            if(!is.null(name)){
              if(length(name) != length(popNames))
                stop("name must be of the same length as the number of populations in multipleFilterResult!")
            }
            for(i in seq_along(popNames)){
              
              thisName <- name[i]
              thisPop <- popNames[i]
              if(is.null(thisName)){
                pop <- thisPop
              }else{
                pop <- thisName
              }
              add(wf, action[[pop]], name = pop, ...)
            }
          })

#' @export 
#' @rdname add
setMethod("Rm",
		signature=c(symbol="character",
				envir="GatingSet",
				subSymbol="character"),
		definition=function(symbol, envir, subSymbol, ...)
		{
			invisible(lapply(envir,function(gh){
#								browser()
								Rm(symbol,gh,subSymbol,...)
							}))
		})
#' @export 
#' @rdname add    
setMethod("Rm",
    signature=c(symbol="character",
        envir="GatingSetList",
        subSymbol="character"),
    definition=function(symbol, envir, subSymbol, ...)
    {
      selectMethod("Rm"
          ,signature = c(symbol="character", envir="GatingSet", subSymbol="character"))(symbol, envir, subSymbol, ...)
    })
    

#' @export 
#' @rdname add
setMethod("Rm",
		signature=c(symbol="character",
				envir="GatingHierarchy",
				subSymbol="character"),
		definition=function(symbol, envir, subSymbol, ...)
		{
            ##remove all children nodes as well
			childrenNodes <- getChildren(envir,symbol)
            #use path instead of unqiue name since the prefix of unique name
            #will change during deletion
			lapply(childrenNodes,function(child)Rm(child,envir))
            
			.cpp_removeNode(envir@pointer,sampleNames(envir), symbol)
		})


    
