\name{add}
\alias{add}
\alias{add,GatingSet,list-method}
\alias{add,GatingSetInternal,filterList-method}
\alias{add,GatingSetInternal,filter-method}
\alias{add,GatingHierarchyInternal,quadGate-method}
\alias{setGate}
\alias{setGate,GatingSetInternal,ANY,list-method}
\alias{setGate,GatingSetInternal,ANY,filterList-method}
\alias{setGate,GatingHierarchyInternal,numeric,filter-method}
\alias{setGate,GatingHierarchyInternal,character,filter-method}
\alias{Rm}
\alias{Rm,character,GatingSetInternal,character-method}
\alias{Rm,character,GatingHierarchyInternal,character-method}
\alias{recompute}
\alias{recompute,GatingSetInternal-method}
\alias{recompute,GatingSet-method}

\title{
Create a GatingSet and add/remove the flowCore gate(or population) to/from a GatingHierarchy/GatingSet.

}
\description{
\code{GatingSet} method creates a gatingset from a flowSet with the ungated data as the root node.
\code{add} method add the flowCore gate to a GatingHierarchy/GatingSet.
\code{setGate} method update the gate of one population node in GatingHierarchy/GatingSet.

\code{Rm} method Remove the population node from a GatingHierarchy/GatingSet. 
They are equivalent to the \code{workFlow},\code{add} and \code{Rm} methods in \code{flowCore} package. 
\code{recompute} method does the actual gating after the gate is added,i.e. calculating the event indices according to the gate definition.   
}
\usage{
\S4method{add}{GatingHierarchyInternal,quadGate}(wf, action, names = NULL,...)
\S4method{add}{GatingSetInternal,filter}(wf, action,...)
\S4method{add}{GatingSetInternal,filterList}(wf, action,...)
\S4method{add}{GatingSet,list}(wf, action,...)

\S4method{setGate}{GatingHierarchyInternal,numeric,filter}(obj, y, value , negated = FALSE,...)
\S4method{setGate}{GatingHierarchyInternal,character,filter}(obj, y, value , ...)
\S4method{setGate}{GatingSetInternal,ANY,filterList}(obj, y, value,...)
\S4method{setGate}{GatingSetInternal,ANY,list}(obj, y, value,...)


\S4method{Rm}{character,GatingHierarchyInternal,character}(symbol,envir,subSymbol,...)
\S4method{Rm}{character,GatingSetInternal,character}(symbol,envir,subSymbol,...)

		
\S4method{recompute}{GatingSetInternal}(x,y)
		
}
\arguments{
  \item{wf}{A \code{GatingHierrarchy} or \code{GatingSet},}

   \item{envir}{A \code{GatingHierrarchy} or \code{GatingSet},}
   
   \item{x}{A \code{GatingSet},}
   
   \item{y}{a node index within a \code{GatingSet}. It is the root node if unspecified.}
	
  \item{action}{
A \code{filter} or a list of \code{filter}s to be added to the  \code{GatingHierarchy} or \code{GatingSet}.
}
   				 
      \item{names}{ a \code{character} vector of length four,which specifies the population names resulted by adding a \code{quadGate}.
                    The order of the names is clock-wise starting from the top left quadrant population.
                    } 
	  
\item{...}{some other arguments to specify how the gates are added to the gating tree.

\itemize{
          \item parent: a \code{character} scalar to specify the parent node name where the new gate to be added to, by default it is NULL,which indicates the root node
          \item name: a \code{character} scalar to specify the node name of population that is generated by the gate to be added.
          			  The default value is NULL,then the name will be extracted from the filterId of the gate to be added 
          \item negated: a \code{logical} scalar to specify whether the gate is negated,which means the the population outside of the gate will be kept as the result population.
          				 It is FALSE by default. 
          
        }
    

}

\item{symbol}{
A \code{character} identifies the population node in a \code{GatingHierrarchy} or \code{GatingSet} to remove
}
\item{subSymbol}{Not used.}
}

\value{
\code{GatingSet} method returns a \code{GatingSet} object with just root node.  
\code{add} method returns a population node ID (or four population node IDs when adding a \code{quadGate}) that uniquely identify the population node within a  \code{GatingHierarchy}.
}
\references{
\url{http://www.rglab.org}
}
\author{
Greg Finak \email{gfinak@fhcrc.org}
Mike Jiang \email{wjiang2@fhcrc.org}
}

\seealso{
\code{\link{GatingSet-class}}
}
\examples{
\dontrun{
data(GvHD)
#select raw flow data
fs<-GvHD[1:3]

#transform the raw data
tf <- transformList(colnames(fs[[1]])[3:6], asinh, transformationId="asinh")
fs_trans<-transform(fs,tf)

#add transformed data to a gatingset
gs <- GatingSet(fs_trans)
gs
getNodes(gs[[1]]) #only contains root node

#add one gate
rg <- rectangleGate("FSC-H"=c(200,400), "SSC-H"=c(250, 400),
                    filterId="rectangle")

nodeID<-add(gs, rg)#it is added to root node by default if parent is not specified
nodeID
getNodes(gs[[1]]) #the second population is named after filterId of the gate 

#add a quadGate
qg <- quadGate("FL1-H"=2, "FL2-H"=4)
nodeIDs<-add(gs,qg,parent="rectangle")
nodeIDs #quadGate produces four population nodes
getNodes(gs[[1]]) #population names are named after dimensions of gate if not specified

#add a boolean Gate
bg<-booleanFilter(`CD15 FITC-CD45 PE+`|`CD15 FITC+CD45 PE-`)
bg
nodeID2<-add(gs,bg,parent="rectangle")
nodeID2
getNodes(gs[[1]])
#do the actual gating
recompute(gs)

#plot one gate for one sample
plotGate(gs[[1]],"rectangle")
plotGate(gs[[1]],nodeIDs) #may be smoothed automatically if there are not enough events after gating

#plot gates across samples using lattice plot
plotGate(gs,nodeID)
#plot all gates for one sample
plotGate(gs[[1]])#boolean gate is skipped by default 
plotGate(gs[[1]],bool=TRUE)

#plot the gating hierarchy
require(Rgraphviz)
plot(gs[[1]])
#remove one node causing the removal of all the descendants 
Rm('rectangle', gs)
getNodes(gs[[1]])
}
}
\keyword{add }
