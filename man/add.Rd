% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/add_Methods.R
\docType{methods}
\name{add}
\alias{add}
\alias{Rm}
\alias{add.default}
\alias{gs_add_gate}
\alias{gs_remove_gate}
\alias{Rm,character,GatingSet,ANY-method}
\alias{Rm,character,GatingSetList,character-method}
\title{Create a GatingSet and add/remove the flowCore gate(or population) to/from a GatingHierarchy/GatingSet.}
\usage{
add(wf, action, ...)

\method{add}{default}(wf, action, ...)

gs_add_gate(wf, action, validityCheck = TRUE, ...)

gs_remove_gate(symbol, envir, ...)

\S4method{Rm}{character,GatingSet,ANY}(symbol, envir, subSymbol, ...)

\S4method{Rm}{character,GatingSetList,character}(symbol, envir, subSymbol,
  ...)
}
\arguments{
\item{wf}{A \code{GatingHierrarchy} or \code{GatingSet}}

\item{action}{A \code{filter} or a list of \code{filter}s to be added to the  \code{GatingHierarchy} or \code{GatingSet}.}

\item{...}{some other arguments to specify how the gates are added to the gating tree.
\itemize{
      \item negated: a \code{logical} scalar to specify whether the gate is negated,which means the the population outside of the gate will be kept as the result population.
      It is FALSE by default. 
 }}

\item{validityCheck}{\code{logical} whether to check the consistency of tree structure across samples. default is TRUE. Can be turned off when speed is prefered to the robustness.}

\item{symbol}{A \code{character} identifies the population node in a \code{GatingHierrarchy} or \code{GatingSet} to remove}

\item{envir}{A \code{GatingHierrarchy} or \code{GatingSet}}

\item{subSymbol}{Not used.}

\item{names}{a \code{character} vector of length four,which specifies the population names resulted by adding a \code{quadGate}.}

\item{parent}{a \code{character} scalar to specify the parent node name where the new gate to be added to, by default it is NULL,which indicates the root node}

\item{name}{a \code{character} scalar to specify the node name of population that is generated by the gate to be added.}

\item{recompute}{a \code{logical} flag
The order of the names is clock-wise starting from the top left quadrant population.}
}
\value{
\code{GatingSet} method returns a \code{GatingSet} object with just root node.  
  \code{add} method returns a population node ID (or four population node IDs when adding a \code{quadGate}) that uniquely identify the population node within a  \code{GatingHierarchy}.
}
\description{
\code{GatingSet} method creates a gatingset from a flowSet with the ungated data as the root node.
\code{add} method add the flowCore gate to a GatingHierarchy/GatingSet.
\code{gs_set_gate} method update the gate of one population node in GatingHierarchy/GatingSet.
\code{Rm} method Remove the population node from a GatingHierarchy/GatingSet. 
They are equivalent to the \code{workFlow},\code{add} and \code{Rm} methods in \code{flowCore} package. 
\code{recompute} method does the actual gating after the gate is added,i.e. calculating the event indices according to the gate definition.
}
\examples{
\dontrun{
    data(GvHD)
#select raw flow data
    fs<-GvHD[1:3]
    
#transform the raw data
    tf <- transformList(colnames(fs[[1]])[3:6], asinh, transformationId="asinh")
    fs_trans<-transform(fs,tf)
    
#add transformed data to a gatingset
    gs <- GatingSet(fs_trans)
    gs
    gs_get_pop_paths(gs[[1]]) #only contains root node
    
#add one gate
    rg <- rectangleGate("FSC-H"=c(200,400), "SSC-H"=c(250, 400),
        filterId="rectangle")
    
    nodeID<-gs_add_gate(gs, rg)#it is added to root node by default if parent is not specified
    nodeID
    gs_get_pop_paths(gs[[1]]) #the second population is named after filterId of the gate 
    
#add a quadGate
    qg <- quadGate("FL1-H"=2, "FL2-H"=4)
    nodeIDs<-gs_add_gate(gs,qg,parent="rectangle")
    nodeIDs #quadGate produces four population nodes
    gs_get_pop_paths(gs[[1]]) #population names are named after dimensions of gate if not specified
    
#add a boolean Gate
    bg<-booleanFilter(`CD15 FITC-CD45 PE+`|`CD15 FITC+CD45 PE-`)
    bg
    nodeID2<-gs_add_gate(gs,bg,parent="rectangle")
    nodeID2
    gs_get_pop_paths(gs[[1]])
#do the actual gating
    recompute(gs)
    
#plot one gate for one sample
    plotGate(gs[[1]],"rectangle")
    plotGate(gs[[1]],nodeIDs) #may be smoothed automatically if there are not enough events after gating
    
#plot gates across samples using lattice plot
    plotGate(gs,nodeID)
#plot all gates for one sample
    plotGate(gs[[1]])#boolean gate is skipped by default 
    plotGate(gs[[1]],bool=TRUE)
    
#plot the gating hierarchy
    plot(gs[[1]])
#remove one node causing the removal of all the descendants 
    gs_remove_gate('rectangle', gs)
    gs_get_pop_paths(gs[[1]])
 }
}
\seealso{
\code{\link{GatingSet-class}}
}
